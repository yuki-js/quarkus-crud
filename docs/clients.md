# Generated Clients & Contract Distribution

Keeping the OpenAPI specification as the source of truth lets us ship consistent SDKs alongside the service. This document explains what gets generated, where artifacts live, and how to consume them.

## Compiled specification

After `compileOpenApi` runs, the bundled spec is copied into `build/resources/main/META-INF/openapi.yaml`. SmallRye OpenAPI serves this exact file at runtime (`/openapi`), so anyone hitting the endpoint gets the same contract that generated the server stubs and tests. If you need to distribute the spec separately, grabbing the file from `build/openapi-compiled/openapi.yaml` ensures you are sharing the build artifact, not hand-edited sources.

## Java interfaces and models

`generateOpenApiModels` (see [openapi-schema.md](openapi-schema.md)) produces interface stubs and DTOs under `app.aoki.quarkuscrud.generated.*`. Although they primarily power the server implementation, you can publish these classes as a standalone artifact if another JVM service wants typed models. Consider adding a Gradle `java-library` submodule if that use case becomes common.

## TypeScript fetch client

The task `generateJavascriptFetchClient` emits a modern `typescript-fetch` client under `build/generated/openapi-clients/javascript-fetch`. Subsequent tasks (`npmInstallJavascriptFetchClient`, `npmBuildJavascriptFetchClient`, `packageJavascriptFetchClient`) install dependencies, build the bundle, and run `npm pack`, producing `build/distributions/yuki-js-quarkus-crud-js-fetch-client-${version}.tgz`.

Publish the tarball to GitHub Packages or any npm-compatible registry. A typical install looks like:

```bash
npm install @yuki-js/quarkus-crud-js-fetch-client --registry=https://npm.pkg.github.com
```

The generated client exposes typed request builders and uses fetch under the hood, so it works in both browsers and Node runtimes. Authentication is left to the consumer; most teams rely on cookies generated by the guest-auth endpoints, so ensure `credentials: 'include'` is set on fetch calls.

## Other languages

Only the TypeScript fetch client is wired into Gradle today, but extending to other generators is straightforward: add another `JavaExec` task that points to the compiled spec, configure the target generator (e.g., `python`, `kotlin`), and hook it into the lifecycle where appropriate.

Because the spec, server stubs, tests, and clients all draw from the same compiled definition, drift is minimized and releases remain boring.
